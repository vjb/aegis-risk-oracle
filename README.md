# üõ°Ô∏è Aegis Risk Oracle

**The Intelligent Guardrail for the Agent Economy**

AI-Powered Risk Assessment Oracle for DeFi Agents using Chainlink CRE.
Aegis is a production-ready risk oracle that prevents AI agents from executing scam trades by analyzing token security, detecting price manipulation, and providing cryptographically-signed risk assessments.

üîó **GitHub:** https://github.com/vjb/aegis-risk-oracle  
üé¨ **Demo Video:** [Link to 3-5 minute demo video] - *Recording in Progress*

---

## üèÜ Hackathon Status: Risk & Compliance

| Requirement | Status | Implementation Details |
| :--- | :---: | :--- |
| **CRE Workflow** | ‚úÖ | Fully validated & simulated using `@chainlink/cre-sdk`. |
| **Chainlink APIs** | ‚úÖ | Parallel fetching of Market Data, Security Scores, and Entropy. |
| **LLM Integration** | ‚úÖ | GPT-4o-mini synthesized Multi-Factor Risk Analysis. |
| **The Triple Lock** | ‚úÖ | ECDSA signatures with Identity, Value, and Time locks. |
| **Sub-second Oracle** | ‚úÖ | Real-time analysis with zero hardcoded "if-then" bottlenecks. |

---

## üß™ Multi-Factor Test Matrix (Proof of Concept)

Aegis is designed to detect "amber" risks that aggregate into a "red" verdict‚Äîsomething static filters miss.

| Scenario | Asset | Verdict | Logic Trigger |
| :--- | :--- | :--- | :--- |
| **Pass** | WETH (Base) | ‚úÖ **EXECUTE** | Low risk, fair price, trusted metadata. |
| **Honeypot** | Generic (BSC) | ‚ùå **REJECT** | Critical Security: `is_honeypot: true` detected externally. |
| **Manipulation** | WETH (Base) | ‚ùå **REJECT** | Economic Attack: Asking price >50% markup over market. |
| **Composite** | SUS-TOKEN | ‚ùå **REJECT** | AI Synthesis: High-Value ($250k) + Proxy/Mintable flags. |
| **Invalid** | N/A | ‚ùå **REJECT** | Data Integrity: Payload failed Zod schema validation. |

---

## üéØ Problem Statement

AI agents are increasingly executing autonomous trades, yet they lack built-in safeguards against **Honeypots**, **Price Manipulation**, and **Contract Malice**. Traditional risk engines rely on brittle, hardcoded rules that scammers easily bypass.

Aegis provides the decentralized "Intelligent Guardrail" agents need for high-stakes DeFi operations.

---

## üß† The "Secret Sauce": AI Synthesis Layer

Unlike traditional risk filters that use static "if-then" logic, Aegis leverages GPT-4o-mini as a **Contextual Synthesis Layer**.

**Static Code vs. Aegis AI Officer**

| Feature | Static Logic (TradFi) | Aegis AI Risk Officer |
| :--- | :--- | :--- |
| **Data Noise** | Fails on unexpected data. | Contextually interprets "noisy" API responses. |
| **Risk Patterns** | Hardcoded checks. | Identifies complex, multi-factor scam patterns. |
| **Synthesis** | Binary: Pass or Fail. | Weighted reasoning: Evaluates the *totality* of risk. |
| **Transparency** | Returns a 403 status. | Returns signed, human-readable reasoning. |

---

## üîê Security Architecture

### The "Triple Lock" Standard
Aegis follows **Chainlink CRE Best Practices** to ensure data integrity and freshness. Our "Triple Lock" signature binds the oracle's verdict to the Identity of the user, the exact Value of the asset, and a 5-minute expiration window‚Äîexactly matching CRE's institutional security standards.

* **Identity Lock:** Prevents signature hijacking.
* **Value Lock:** Ensures price immutability.
* **Time Lock:** Prevents late-replay attacks (CRE 5-min standard).

These protections are provable on-chain and demonstrated in our Cryptographic Security Phase.

### Trust Architecture: The Signer & The Vault
Aegis uses standard asymmetric cryptography to bridge the "Off-Chain" and "On-Chain" worlds trustlessly.

1.  **Off-Chain (The Signer):**
    The Chainlink CRE environment holds a secure **Private Key**. Once the AI Risk Officer calculates a verdict, the CRE signs a hash of the data `(RiskScore + Price + UserAddress + Timestamp)` using this private key. This ensures the data originated from the trusted Aegis hardware and hasn't been tampered with.

2.  **On-Chain (The Vault):**
    The `AegisVault.sol` smart contract is deployed with the corresponding **Public Key** hardcoded (or stored in state).
    * **Verification:** When the agent submits the transaction, the contract uses `ecrecover` to compare the signature against the stored Public Key.
    * **Enforcement:** If the signature doesn't match the Public Key, the transaction reverts immediately. This means **only** risk assessments generated by the authorized Chainlink CRE can unlock funds.

---

## üõ†Ô∏è AI Evaluation Flow

```mermaid
flowchart TD
    subgraph Data_Inputs ["Step 1: Raw Signals"]
        direction LR
        A[Price Delta] ~~~ B[Security Flags] ~~~ C[Trade Value] ~~~ D[Contract Metadata]
    end

    subgraph LLM_Synthesis ["Step 2: AI Synthesis Layer"]
        S1{Contextual Evaluation}
        S2{Pattern Identification}
        S3{Multi-Factor Weighting}
        S1 --> S2 --> S3
    end

    subgraph Output ["Step 3: Verifiable Result"]
        V[Signed Verdict & Reasoning]
    end

    Data_Inputs --> LLM_Synthesis
    LLM_Synthesis --> Output
```

---

## üèóÔ∏è Technical Architecture

### ‚ö° Best Practice: Parallel Data Acquisition

Aegis utilizes the **Chainlink CRE** runtime to fetch Market Data, Security Scores, and Entropy in parallel, drastically reducing latency for real-time AI decision-making.

```mermaid
sequenceDiagram
    participant Agent as AI Agent (ElizaOS, LangChain, etc.)
    participant Oracle as Aegis Risk Oracle (CRE DON)
    participant APIs as External APIs (CoinGecko, GoPlus, QRNG, OpenAI)
    participant Vault as Vault (Smart Contract)

    Agent->>Oracle: POST /risk-assessment (token, chain, amount)
    
    rect rgb(240, 240, 240)
    note right of Oracle: Parallel Fetching
    par Fetch Market Data
        Oracle->>APIs: Get Price (CoinGecko)
    and Fetch Security Data
        Oracle->>APIs: Get Security (GoPlus)
    and Fetch Entropy
        Oracle->>APIs: Get Entropy (QRNG)
    end
    APIs-->>Oracle: Return Data
    end

    Oracle->>APIs: AI Risk Analysis (OpenAI GPT-4o-mini)
    APIs-->>Oracle: Return Analysis
    
    Oracle->>Oracle: Sign Result with "Triple Lock"
    Note right of Oracle: (Identity + Value + Time Locks)
    Oracle-->>Agent: Signed Result (Score, Verdict, Sig)
    
    Agent->>Vault: swapWithOracle(...)
    Vault->>Vault: Verify Triple Lock Signature -> Execute
```

---

## ‚õìÔ∏è Chainlink CRE Integration

This project is built using the **Chainlink Runtime Environment (CRE)** to ensure decentralization and verifiability.

**Key Implementation Highlights**
* **Workflow Entry:** `aegis-workflow/main.ts`
* **Prompt Logic:** Implements "Strict Math" rules for risk threshold enforcement.
* **Capability Usage:** Uses `HTTPClient` for low-latency parallelized fetching.

```typescript
// Aegis utilizes the CRE SDK for orchestration
import { HTTPCapability, handler, cre } from "@chainlink/cre-sdk";

const http = new HTTPCapability();
const httpClient = new cre.capabilities.HTTPClient();

// Parallelized fetching pattern
const [price, entropy, security] = await Promise.all([ ... ]);
```

---

## üöÄ Quick Start (Simulation)

### Prerequisites
- Docker (recommended) OR Node.js 18+
- [Chainlink CRE CLI](https://docs.chain.link/chainlink-local/build/cre/installation)

### Run the Demo Suite (via Docker)
```bash
# Build & Run Development Container
docker build -t aegis-dev .
docker run -it --name aegis_dev aegis-dev bash

# Execute Phase 1: AI Risk Analysis
./test-aegis.ps1

# Execute Phase 2: Cryptographic Security Proofs
./test-crypto.ps1
```

---

## ü§ñ Developer's Hub: Agent Integration

Aegis is built to be the security standard for autonomous agents. Integrating Aegis into your agent (ElizaOS, LangChain, etc.) ensures that every trade intent is validated against a decentralized risk engine before it hits the chain.

### üõ°Ô∏è Aegis ElizaOS Plugin (Draft)
We've provided a draft implementation for ElizaOS in the `integrations/elizaos/` directory:
* **`aegis-plugin.ts`**: Intercepts `SWAP` and `BUY` intents. It automatically calls the Aegis Oracle and blocks the trade if the risk score is too high.
* **`aegis-provider.ts`**: A cryptographic utility that allows the agent to verify the DON's signature locally. **This is the "Safe Agent" standard.**

### üõ†Ô∏è Integration Example
```typescript
// Intercept intent and check risk
const oracleResponse = await aegisPlugin.handler(runtime, intent);

if (oracleResponse.decision === "REJECT") {
    agent.say(`Trade blocked: ${oracleResponse.reasoning}`);
    return; // Safety lock
}

// If approved, sign with the Oracle's verifiable verdict
executeTransaction(intent, oracleResponse.signature);
```

---

**‚ö†Ô∏è Disclaimer**: This is a hackathon demo. Not audited for production use.
